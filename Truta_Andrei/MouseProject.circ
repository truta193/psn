<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project source="3.7.2" version="1.0">
  This file is intended to be loaded by Logisim-evolution v3.7.2(https://github.com/logisim-evolution/).

  <lib desc="#Wiring" name="0">
    <tool name="Pin">
      <a name="appearance" val="classic"/>
    </tool>
  </lib>
  <lib desc="#Gates" name="1"/>
  <lib desc="#Plexers" name="2"/>
  <lib desc="#Arithmetic" name="3"/>
  <lib desc="#Memory" name="4"/>
  <lib desc="#I/O" name="5"/>
  <lib desc="#TTL" name="6"/>
  <lib desc="#TCL" name="7"/>
  <lib desc="#Base" name="8"/>
  <lib desc="#BFH-Praktika" name="9"/>
  <lib desc="#Input/Output-Extra" name="10"/>
  <lib desc="#Soc" name="11"/>
  <main name="main"/>
  <options>
    <a name="gateUndefined" val="ignore"/>
    <a name="simlimit" val="1000"/>
    <a name="simrand" val="0"/>
  </options>
  <mappings>
    <tool lib="8" map="Button2" name="Menu Tool"/>
    <tool lib="8" map="Button3" name="Menu Tool"/>
    <tool lib="8" map="Ctrl Button1" name="Menu Tool"/>
  </mappings>
  <toolbar>
    <tool lib="8" name="Poke Tool"/>
    <tool lib="8" name="Edit Tool"/>
    <tool lib="8" name="Wiring Tool"/>
    <tool lib="8" name="Text Tool"/>
    <sep/>
    <tool lib="0" name="Pin"/>
    <tool lib="0" name="Pin">
      <a name="facing" val="west"/>
      <a name="output" val="true"/>
    </tool>
    <sep/>
    <tool lib="1" name="NOT Gate"/>
    <tool lib="1" name="AND Gate"/>
    <tool lib="1" name="OR Gate"/>
    <tool lib="1" name="XOR Gate"/>
    <tool lib="1" name="NAND Gate"/>
    <tool lib="1" name="NOR Gate"/>
    <sep/>
    <tool lib="4" name="D Flip-Flop"/>
    <tool lib="4" name="Register"/>
  </toolbar>
  <circuit name="main">
    <a name="appearance" val="logisim_evolution"/>
    <a name="circuit" val="main"/>
    <a name="circuitnamedboxfixedsize" val="true"/>
    <a name="downloadBoard" val="BASYS3_CB17"/>
    <a name="downloadFrequency" val="2.0"/>
    <a name="simulationFrequency" val="64.0"/>
    <boardmap boardname="BASYS3_CB17">
      <mc key="/ANODES" pmap="273_234_0,225_234_0,180_234_0,130_234_0"/>
      <mc key="/CATODES" pmap="138_258_0,130_249_0,130_263_0,136_274_0,154_262_0,154_248_0,136_245_0"/>
      <mc key="/CLOCK" map="321,237"/>
      <mc key="/IS_LEFT" map="92,295"/>
      <mc key="/PCLOCK" map="527,86"/>
      <mc key="/PDATA" map="544,104"/>
      <mc key="/RESET" map="78,323"/>
      <mc key="/REVERSE" map="117,323"/>
    </boardmap>
    <comp lib="0" loc="(110,150)" name="Pin">
      <a name="appearance" val="NewPins"/>
      <a name="label" val="CLOCK"/>
    </comp>
    <comp lib="0" loc="(110,170)" name="Pin">
      <a name="appearance" val="NewPins"/>
      <a name="label" val="RESET"/>
    </comp>
    <comp lib="0" loc="(110,190)" name="Pin">
      <a name="appearance" val="NewPins"/>
      <a name="label" val="REVERSE"/>
    </comp>
    <comp lib="0" loc="(1450,270)" name="Pin">
      <a name="appearance" val="NewPins"/>
      <a name="facing" val="west"/>
      <a name="label" val="ANODES"/>
      <a name="output" val="true"/>
      <a name="width" val="4"/>
    </comp>
    <comp lib="0" loc="(1450,290)" name="Pin">
      <a name="appearance" val="NewPins"/>
      <a name="facing" val="west"/>
      <a name="label" val="CATODES"/>
      <a name="output" val="true"/>
      <a name="width" val="7"/>
    </comp>
    <comp lib="0" loc="(210,430)" name="Pin">
      <a name="appearance" val="NewPins"/>
      <a name="label" val="PCLOCK"/>
    </comp>
    <comp lib="0" loc="(210,450)" name="Pin">
      <a name="appearance" val="NewPins"/>
      <a name="label" val="PDATA"/>
    </comp>
    <comp lib="0" loc="(880,80)" name="Pin">
      <a name="appearance" val="NewPins"/>
      <a name="facing" val="west"/>
      <a name="label" val="IS_LEFT"/>
      <a name="output" val="true"/>
    </comp>
    <comp loc="(1130,150)" name="COUNTER">
      <a name="appearance" val="logisim_evolution"/>
      <a name="label" val="counter_1"/>
    </comp>
    <comp loc="(1450,270)" name="SSD_MANAGER">
      <a name="appearance" val="logisim_evolution"/>
      <a name="label" val="ssd_manager_1"/>
    </comp>
    <comp loc="(600,390)" name="PS2_READER">
      <a name="appearance" val="logisim_evolution"/>
      <a name="label" val="ps2_reader_1"/>
    </comp>
    <comp loc="(770,150)" name="CONTROL_UNIT">
      <a name="appearance" val="logisim_evolution"/>
      <a name="label" val="control_unit_1"/>
    </comp>
    <wire from="(110,150)" to="(360,150)"/>
    <wire from="(110,170)" to="(330,170)"/>
    <wire from="(110,190)" to="(550,190)"/>
    <wire from="(1130,150)" to="(1160,150)"/>
    <wire from="(1160,150)" to="(1160,310)"/>
    <wire from="(1160,310)" to="(1230,310)"/>
    <wire from="(1230,110)" to="(1230,270)"/>
    <wire from="(210,430)" to="(380,430)"/>
    <wire from="(210,450)" to="(380,450)"/>
    <wire from="(330,170)" to="(330,410)"/>
    <wire from="(330,170)" to="(530,170)"/>
    <wire from="(330,410)" to="(380,410)"/>
    <wire from="(360,150)" to="(360,390)"/>
    <wire from="(360,150)" to="(510,150)"/>
    <wire from="(360,390)" to="(380,390)"/>
    <wire from="(510,110)" to="(510,150)"/>
    <wire from="(510,110)" to="(860,110)"/>
    <wire from="(510,150)" to="(550,150)"/>
    <wire from="(520,210)" to="(520,300)"/>
    <wire from="(520,210)" to="(550,210)"/>
    <wire from="(520,300)" to="(630,300)"/>
    <wire from="(530,130)" to="(530,170)"/>
    <wire from="(530,130)" to="(850,130)"/>
    <wire from="(530,170)" to="(550,170)"/>
    <wire from="(540,230)" to="(540,280)"/>
    <wire from="(540,230)" to="(550,230)"/>
    <wire from="(540,280)" to="(650,280)"/>
    <wire from="(600,390)" to="(630,390)"/>
    <wire from="(600,410)" to="(650,410)"/>
    <wire from="(630,300)" to="(630,390)"/>
    <wire from="(650,280)" to="(650,410)"/>
    <wire from="(770,170)" to="(830,170)"/>
    <wire from="(770,190)" to="(810,190)"/>
    <wire from="(770,80)" to="(770,150)"/>
    <wire from="(770,80)" to="(880,80)"/>
    <wire from="(810,190)" to="(810,210)"/>
    <wire from="(810,210)" to="(910,210)"/>
    <wire from="(830,170)" to="(830,190)"/>
    <wire from="(830,190)" to="(910,190)"/>
    <wire from="(850,130)" to="(850,170)"/>
    <wire from="(850,170)" to="(890,170)"/>
    <wire from="(860,110)" to="(1230,110)"/>
    <wire from="(860,110)" to="(860,150)"/>
    <wire from="(860,150)" to="(910,150)"/>
    <wire from="(890,170)" to="(890,290)"/>
    <wire from="(890,170)" to="(910,170)"/>
    <wire from="(890,290)" to="(1230,290)"/>
  </circuit>
  <vhdl name="PS2_READER">library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;

entity PS2_READER is
	port (
		CLOCK : in std_logic;
		RESET : in std_logic;
		PS2_CLOCK : in std_logic;
		PS2_DATA : in std_logic;
		LEFT_CLICK : out std_logic;
		RIGHT_CLICK : out std_logic
	);
end PS2_READER;

architecture Behavioral of PS2_READER is
	signal MOUSE_REGISTER : std_logic_vector(42 downto 0) := (others =&gt; '0');
	signal MOUSE_BITS : std_logic_vector(5 downto 0) := (others =&gt; '0');
	signal REGISTER_FULL : std_logic;
	signal IS_LEFT_PRESSED : std_logic := '0';
	signal IS_RIGHT_PRESSED : std_logic := '0';
	signal IDLE : std_logic := '1';
 
begin
	BIT_COUNT_PROCESS : process (PS2_CLOCK, RESET)
	begin
		if RESET = '0' then
			MOUSE_BITS &lt;= (others =&gt; '0');
		elsif falling_edge(PS2_CLOCK) then
			if MOUSE_BITS &lt;= 42 then
				MOUSE_BITS &lt;= MOUSE_BITS + 1;
			else
				MOUSE_BITS &lt;= (others =&gt; '0');
			end if;
		end if;
	end process;

	REGISTER_PROCESS : process (PS2_CLOCK, RESET)
	begin
		REGISTER_FULL &lt;= '0';
		if RESET = '0' then
			MOUSE_REGISTER &lt;= (others =&gt; '0');
		elsif falling_edge(PS2_CLOCK) then
			MOUSE_REGISTER &lt;= MOUSE_REGISTER(41 downto 0) &amp; PS2_DATA;
			if MOUSE_BITS = 42 then
				REGISTER_FULL &lt;= '1';
			end if;
		end if;
	end process;

	SIGNAL_PROCESS: process (CLOCK)
	begin
		if rising_edge(CLOCK) then
			LEFT_CLICK &lt;= '0';
			RIGHT_CLICK &lt;= '0';
			
			if REGISTER_FULL = '1' then
				
				if MOUSE_REGISTER(41) = '1' and IS_LEFT_PRESSED = '0' then
					LEFT_CLICK &lt;= '1';
				elsif MOUSE_REGISTER(40) = '1' and IS_RIGHT_PRESSED = '0' then
					RIGHT_CLICK &lt;= '1';
				end if;
				IS_LEFT_PRESSED &lt;= MOUSE_REGISTER(41);
				IS_RIGHT_PRESSED &lt;= MOUSE_REGISTER(40);
			end if;	
		end if;
	end process;
--	COUNTER_PROCESS : process (CLOCK, RESET)
--	begin
--		if RESET = '0' then
--			CLICK_COUNT &lt;= (others =&gt; '0');
--		elsif rising_edge(CLOCK) then
--			if REGISTER_FULL = '1' then
--				if MOUSE_REGISTER(41) = '1' and IS_LEFT_PRESSED = '0' then
--					CLICK_COUNT &lt;= CLICK_COUNT + 1;
--				elsif MOUSE_REGISTER(40) = '1' and IS_RIGHT_PRESSED = '0' then
--					CLICK_COUNT &lt;= CLICK_COUNT - 1;
--				end if;
--				IS_LEFT_PRESSED &lt;= MOUSE_REGISTER(41);
--				IS_RIGHT_PRESSED &lt;= MOUSE_REGISTER(40);
--			end if;
--		end if;
--
--		TEST &lt;= CLICK_COUNT;
--	end process;
end Behavioral;













</vhdl>
  <vhdl name="COUNTER">LIBRARY ieee;&#13;
USE ieee.std_logic_1164.all;&#13;
use ieee.std_logic_unsigned.all;&#13;

ENTITY COUNTER IS&#13;
  PORT (&#13;
  	CLOCK: in std_logic;
  	RESET: in std_logic;
  	INCREMENT, DECREMENT: in std_logic;
  	OUTNUMBER: out std_logic_vector(15 downto 0)
    );&#13;
END COUNTER;&#13;



ARCHITECTURE Behavioral OF COUNTER IS&#13;
&#13;signal NUMBER: std_logic_vector(15 downto 0) := (others =&gt; '0');
BEGIN&#13;
&#13;	CLOCK_ACTIVE: process (CLOCK, RESET)
	begin
		if RESET = '0' then
			NUMBER &lt;= (others =&gt; '0');
		elsif rising_edge(CLOCK) then
			if INCREMENT = '1' then
				if NUMBER &lt; 9999 then
					NUMBER &lt;= NUMBER + 1;
				else
					NUMBER &lt;= "0010011100001111"; --9999
				end if;
			elsif DECREMENT = '1' then
				if NUMBER &gt; 0 then
					NUMBER &lt;= NUMBER - 1;
				else 
					NUMBER &lt;= (others =&gt; '0');
				end if;
			end if;
		end if;
		OUTNUMBER &lt;= NUMBER;
	end process;
&#13;
END Behavioral;&#13;
</vhdl>
  <vhdl name="CONTROL_UNIT">LIBRARY ieee;&#13;
USE ieee.std_logic_1164.all;&#13;
&#13;
ENTITY CONTROL_UNIT IS&#13;
  PORT (&#13;
	CLOCK: in std_logic;
	RESET: in std_logic;
	REVERSE: in std_logic;
	LEFT_CLICK, RIGHT_CLICK: in std_logic;
	IS_LEFT, INC, DEC: out std_logic
    );&#13;
END CONTROL_UNIT;&#13;
&#13;
&#13;
ARCHITECTURE Behavioral OF CONTROL_UNIT IS&#13;
&#13;
BEGIN&#13;
&#13;	CONTROL_UNIT: process (CLOCK, RESET)
	begin
		if RESET = '0' then
			INC &lt;= '0';
			DEC &lt;= '0';
		elsif rising_edge(CLOCK) then
			INC &lt;= '0';
			DEC &lt;= '0';
			if REVERSE = '0' then
				IS_LEFT &lt;= '1';
				if LEFT_CLICK = '1' then
					INC &lt;= '1';
		
				elsif RIGHT_CLICK = '1' then
					DEC &lt;= '1';
					
				end if;
			else
				IS_LEFT &lt;= '0';
				if LEFT_CLICK = '1' then
					DEC &lt;= '1';
					
				elsif RIGHT_CLICK = '1' then
					INC &lt;= '1';
					
				end if;
				
			end if;
		end if;
	end process;
&#13;
END Behavioral;&#13;
</vhdl>
  <vhdl name="BCD7SGT">LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY BCD7SGT IS
  PORT (
  	INPUT: in std_logic_vector(3 downto 0);
  	OUTPUT: out std_logic_vector(6 downto 0)
    );
END BCD7SGT;


ARCHITECTURE Behavioral OF BCD7SGT IS

BEGIN
	with INPUT select OUTPUT &lt;=
		"1111110" when "0000",
		"0110000" when "0001",
		"1101101" when "0010",
		"1111001" when "0011",
		"0110011" when "0100",
		"1011011" when "0101",
		"1011111" when "0110",
		"1110000" when "0111",
		"1111111" when "1000",
		"1111011" when "1001",
		"1110111" when "1010",
		"0011111" when "1011",
		"1001110" when "1100",
		"0111101" when "1101",
		"1001111" when "1110",
		"1000111" when "1111",
		"0000000" when others;
END Behavioral;
</vhdl>
  <vhdl name="RING_SHIFTER">LIBRARY ieee;&#13;
USE ieee.std_logic_1164.all;&#13;
use ieee.std_logic_unsigned.all;&#13;

ENTITY RING_SHIFTER IS&#13;
  PORT (&#13;
	CLOCK: in std_logic;
	RESET: in std_logic;
	OUTPUT: out std_logic_vector(3 downto 0)
    );&#13;
END RING_SHIFTER;&#13;
&#13;
ARCHITECTURE TypeArchitecture OF RING_SHIFTER IS&#13;
	signal CONTENT: std_logic_vector(3 downto 0) := "0001";&#13;
BEGIN&#13;
&#13;	CLOCK_SIGNAL: process (CLOCK, RESET)
	begin
		if RESET = '0' then
			CONTENT &lt;= "0001";
		elsif rising_edge(CLOCK) then
			CONTENT &lt;= CONTENT(0) &amp; CONTENT(3 downto 1);
		end if;
		OUTPUT &lt;= CONTENT;

	end process;
&#13;
END TypeArchitecture;&#13;
</vhdl>
  <vhdl name="MUX4TO1">LIBRARY ieee;
USE ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;

ENTITY MUX4TO1 IS
  PORT (
	INPUT1: in std_logic_vector(3 downto 0);
	INPUT2: in std_logic_vector(3 downto 0);
	INPUT3: in std_logic_vector(3 downto 0);
	INPUT4: in std_logic_vector(3 downto 0);
	SELECTION: in std_logic_vector(1 downto 0);
	OUTPUT: out std_logic_vector(3 downto 0)
    );
END MUX4TO1;

ARCHITECTURE Behavioral OF MUX4TO1 IS
BEGIN

	OUTPUT &lt;= INPUT1 when SELECTION = "00" else
		INPUT2 when SELECTION = "01" else
	 	INPUT3 when SELECTION = "10" else 
	 	INPUT4 when SELECTION = "11";

END Behavioral;
</vhdl>
  <vhdl name="PRIORITY_ENCODER">LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY PRIORITY_ENCODER IS
  PORT (
	INPUT: in std_logic_vector(3 downto 0);
	OUTPUT: out std_logic_vector(1 downto 0)
    );
END PRIORITY_ENCODER;


ARCHITECTURE Behavioral OF PRIORITY_ENCODER IS

BEGIN

	OUTPUT &lt;= "11" when INPUT(3) = '1' else
			"10" when INPUT(3 downto 2) = "01" else
			"01" when INPUT(3 downto 1) = "001" else
			"00" when INPUT(3 downto 0) = "0001";

END Behavioral;
</vhdl>
  <vhdl name="DIGIT_SPLITTER">LIBRARY ieee;&#13;
USE ieee.std_logic_1164.all;&#13;
use ieee.std_logic_unsigned.all;&#13;
use ieee.numeric_std.all;

ENTITY DIGIT_SPLITTER IS&#13;
  PORT (&#13;
	NUMBER: in std_logic_vector(15 downto 0);
	D1, D2, D3, D4: out std_logic_vector(3 downto 0)
    );&#13;
END DIGIT_SPLITTER;&#13;
&#13;

ARCHITECTURE Behavioral OF DIGIT_SPLITTER IS&#13;

BEGIN&#13;
	SPLIT: process(NUMBER) 
	variable DECIMAL : integer := 0;
	variable N: integer := 0;
	begin
		N := conv_integer(NUMBER);
		DECIMAL := N rem 10;
		D1 &lt;= std_logic_vector(to_unsigned(DECIMAL, 4));
		N := N / 10;
		DECIMAL := N rem 10;
		D2 &lt;= std_logic_vector(to_unsigned(DECIMAL, 4));
		N := N / 10;
		DECIMAL := N rem 10;
		D3 &lt;= std_logic_vector(to_unsigned(DECIMAL, 4));
		N := N / 10;
		DECIMAL := N rem 10;
		D4 &lt;= std_logic_vector(to_unsigned(DECIMAL, 4));
	end process;
&#13;
END Behavioral;&#13;
</vhdl>
  <vhdl name="FREQUENCY_DIVIDER">LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;

ENTITY FREQUENCY_DIVIDER IS
  PORT (
  	CLOCK_100: in std_logic;
  	RESET: in std_logic;
  	CLK_DIVIDED: out std_logic
	);
END FREQUENCY_DIVIDER;


ARCHITECTURE Behavioral OF FREQUENCY_DIVIDER IS

BEGIN

	process(CLOCK_100)
	variable nr: std_logic_vector (15 downto 0) := (others =&gt; '0');
	begin
		if RESET = '0' then
			nr := (others =&gt; '0');
		elsif rising_edge(CLOCK_100) then
			nr := nr + 1;
		end if;
		CLK_DIVIDED &lt;= nr(15);
	end process;

END Behavioral;
</vhdl>
  <vhdl name="SSD_MANAGER">LIBRARY ieee;&#13;
USE ieee.std_logic_1164.all;&#13;
&#13;
ENTITY SSD_MANAGER IS&#13;
  PORT (&#13;
  	CLOCK: in std_logic;
  	RESET: in std_logic;
	NUMBER: in std_logic_vector(15 downto 0);
	ANODES: out std_logic_vector(3 downto 0);
	CATODES: out std_logic_vector(6 downto 0)
    );&#13;
END SSD_MANAGER;&#13;
&#13;

ARCHITECTURE Structural OF SSD_MANAGER IS&#13;
	&#13;COMPONENT FREQUENCY_DIVIDER IS
	  PORT (
	  	CLOCK_100: in std_logic;
	  	RESET: in std_logic;
	  	CLK_DIVIDED: out std_logic
		);
	END component;

	component RING_SHIFTER IS
	  PORT (
		CLOCK: in std_logic;
		RESET: in std_logic;
		OUTPUT: out std_logic_vector(3 downto 0)
	    );
	END component;

	component PRIORITY_ENCODER IS
		  PORT (
			INPUT: in std_logic_vector(3 downto 0);
			OUTPUT: out std_logic_vector(1 downto 0)
		    );
	END component;

	component DIGIT_SPLITTER IS
	  PORT (
		NUMBER: in std_logic_vector(15 downto 0);
		D1, D2, D3, D4: out std_logic_vector(3 downto 0)
	    );
	END component;

	component MUX4TO1 IS
	  PORT (
		INPUT1: in std_logic_vector(3 downto 0);
		INPUT2: in std_logic_vector(3 downto 0);
		INPUT3: in std_logic_vector(3 downto 0);
		INPUT4: in std_logic_vector(3 downto 0);
		SELECTION: in std_logic_vector(1 downto 0);
		OUTPUT: out std_logic_vector(3 downto 0)
	    );
	END component;

	component BCD7SGT IS
	  PORT (
	  	INPUT: in std_logic_vector(3 downto 0);
	  	OUTPUT: out std_logic_vector(6 downto 0)
	    );
	END component;

	signal CLOCK_DIVIDED: std_logic;
	signal ANODES_SIGNAL: std_logic_vector(3 downto 0);
	signal ANODE_SELECT: std_logic_vector(1 downto 0);
	signal DIGIT_SELECT: std_logic_vector(3 downto 0);
	signal DIGIT1, DIGIT2, DIGIT3, DIGIT4: std_logic_vector(3 downto 0);

BEGIN&#13;
&#13;
FREQ_DIV: FREQUENCY_DIVIDER port map(CLOCK, RESET, CLOCK_DIVIDED);
RING_SHIFT: RING_SHIFTER port map(CLOCK_DIVIDED, RESET, ANODES_SIGNAL);
ANODES &lt;= ANODES_SIGNAL;
PRIORITY_ENC: PRIORITY_ENCODER port map(ANODES_SIGNAL, ANODE_SELECT);
DIGIT_SPLT: DIGIT_SPLITTER port map(NUMBER, DIGIT1, DIGIT2, DIGIT3, DIGIT4);
&#13;MUX: MUX4TO1 port map(DIGIT1, DIGIT2, DIGIT3, DIGIT4, ANODE_SELECT, DIGIT_SELECT);
DIGIT_DEC: BCD7SGT port map(DIGIT_SELECT, CATODES);
END Structural;&#13;


-------------------------------------------------------
------------------ FREQUENCY DIVIDER ------------------
-------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;

ENTITY FREQUENCY_DIVIDER IS
  PORT (
  	CLOCK_100: in std_logic;
  	RESET: in std_logic;
  	CLK_DIVIDED: out std_logic
	);
END FREQUENCY_DIVIDER;


ARCHITECTURE Behavioral OF FREQUENCY_DIVIDER IS

BEGIN

	process(CLOCK_100)
	variable nr: std_logic_vector (15 downto 0) := (others =&gt; '0');
	begin
		if RESET = '0' then
			nr := (others =&gt; '0');
		elsif rising_edge(CLOCK_100) then
			nr := nr + 1;
		end if;
		--CHANGE TO 15
		CLK_DIVIDED &lt;= nr(15);
	end process;

END Behavioral;


-------------------------------------------------------
--------------------- RING SHIFTER --------------------
-------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;

ENTITY RING_SHIFTER IS
  PORT (
	CLOCK: in std_logic;
	RESET: in std_logic;
	OUTPUT: out std_logic_vector(3 downto 0)
    );
END RING_SHIFTER;

ARCHITECTURE TypeArchitecture OF RING_SHIFTER IS
	signal CONTENT: std_logic_vector(3 downto 0) := "0001";
BEGIN

	CLOCK_SIGNAL: process (CLOCK)
	begin
		
		if RESET = '0' then
			CONTENT &lt;= "0001";
		elsif rising_edge(CLOCK) then
			CONTENT &lt;= CONTENT(0) &amp; CONTENT(3 downto 1);
		end if;

		OUTPUT &lt;= CONTENT;

	end process;

END TypeArchitecture;




-------------------------------------------------------
------------------- PROPRITY ENCODER ------------------
-------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY PRIORITY_ENCODER IS
  PORT (
	INPUT: in std_logic_vector(3 downto 0);
	OUTPUT: out std_logic_vector(1 downto 0)
    );
END PRIORITY_ENCODER;

ARCHITECTURE Behavioral OF PRIORITY_ENCODER IS

BEGIN

	OUTPUT &lt;= "11" when INPUT(3) = '1' else
			"10" when INPUT(3 downto 2) = "01" else
			"01" when INPUT(3 downto 1) = "001" else
			"00" when INPUT(3 downto 0) = "0001";

END Behavioral;


-------------------------------------------------------
------------------- DIGIT_SPLITTER --------------------
-------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;
use ieee.numeric_std.all;

ENTITY DIGIT_SPLITTER IS
  PORT (
	NUMBER: in std_logic_vector(15 downto 0);
	D1, D2, D3, D4: out std_logic_vector(3 downto 0)
    );
END DIGIT_SPLITTER;


ARCHITECTURE Behavioral OF DIGIT_SPLITTER IS

BEGIN
	SPLIT: process(NUMBER) 
	variable DECIMAL : integer := 0;
	variable N: integer := 0;
	begin
		N := conv_integer(NUMBER);
		DECIMAL := N rem 10;
		D1 &lt;= std_logic_vector(to_unsigned(DECIMAL, 4));
		N := N / 10;
		DECIMAL := N rem 10;
		D2 &lt;= std_logic_vector(to_unsigned(DECIMAL, 4));
		N := N / 10;
		DECIMAL := N rem 10;
		D3 &lt;= std_logic_vector(to_unsigned(DECIMAL, 4));
		N := N / 10;
		DECIMAL := N rem 10;
		D4 &lt;= std_logic_vector(to_unsigned(DECIMAL, 4));
	end process;

END Behavioral;


-------------------------------------------------------
------------------ MUX 4 TO 1 4BIT --------------------
-------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;

ENTITY MUX4TO1 IS
  PORT (
	INPUT1: in std_logic_vector(3 downto 0);
	INPUT2: in std_logic_vector(3 downto 0);
	INPUT3: in std_logic_vector(3 downto 0);
	INPUT4: in std_logic_vector(3 downto 0);
	SELECTION: in std_logic_vector(1 downto 0);
	OUTPUT: out std_logic_vector(3 downto 0)
    );
END MUX4TO1;

ARCHITECTURE Behavioral OF MUX4TO1 IS
BEGIN

	OUTPUT &lt;= INPUT1 when SELECTION = "00" else
		INPUT2 when SELECTION = "01" else
	 	INPUT3 when SELECTION = "10" else 
	 	INPUT4 when SELECTION = "11";

END Behavioral;



-------------------------------------------------------
------------------- BCD TO 7 SEGMENT ------------------
-------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY BCD7SGT IS
  PORT (
  	INPUT: in std_logic_vector(3 downto 0);
  	OUTPUT: out std_logic_vector(6 downto 0)
    );
END BCD7SGT;


ARCHITECTURE Behavioral OF BCD7SGT IS

BEGIN
	with INPUT select OUTPUT &lt;=
		"1111110" when "0000",
		"0110000" when "0001",
		"1101101" when "0010",
		"1111001" when "0011",
		"0110011" when "0100",
		"1011011" when "0101",
		"1011111" when "0110",
		"1110000" when "0111",
		"1111111" when "1000",
		"1111011" when "1001",
		"1110111" when "1010",
		"0011111" when "1011",
		"1001110" when "1100",
		"0111101" when "1101",
		"1001111" when "1110",
		"1000111" when "1111",
		"0000000" when others;
END Behavioral;


</vhdl>
  <vhdl name="Debouncer">library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity Debouncer is
    Port (
        clk    : in  STD_LOGIC;
        button : in  STD_LOGIC;
        debounced_button : out STD_LOGIC
    );
end Debouncer;

architecture Behavioral of Debouncer is
    signal shift_reg : STD_LOGIC_VECTOR(9 downto 0);
    signal debounced_button_reg : STD_LOGIC;
begin
    process (clk)
    begin
        if falling_edge(clk) then
            shift_reg &lt;= shift_reg(8 downto 0) &amp; button;
            if shift_reg = "1111111111" then
            	debounced_button_reg &lt;= '0';
            else 
			debounced_button_reg &lt;= '1';
            end if;
            
        end if;
    end process;

    debounced_button &lt;= debounced_button_reg;
end Behavioral;
</vhdl>
</project>
